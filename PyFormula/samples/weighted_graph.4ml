domain WeightedGraph
{
	Ints ::= new (item: Integer, nxt: any Ints + {NIL}).
	Node ::= new (id: String).
	Edge ::= new (src: Node, dst: Node, weight: Integer).
	Nodes ::= new (item: Node, nxt: any Nodes + {NIL}).
	path ::= new (src: Node, dst: Node, weight: Integer).

	// A detailed path enumerating every nodes along the path.
	detailedPath ::= new (src: Node, dst: Node, weight: Integer, ps: paths).
	paths ::= new (item: path, nxt: any paths + {NIL}).

	// The number of paths from point A to point B
	pathCount ::= new (src: Node, dst: Node, num: Integer).

	// The shortest path between two nodes.
	shortestPath ::= new (src: Node, dst: Node, shortest: Integer).

	// Return all possible path length between two nodes.
	allPathLength ::= new (src: Node, dst: Node, ints: Ints).

	//containsSubterm ::= new (t1: Nodes, t2: Nodes).
	//Looks like isSubterm() is not implemented?
	//containsSubterm(t1, t2) :- t1 : Nodes, t2 : Nodes, isSubterm(t1, t2).

	path(a, b, w) :- Edge(a, b, w).
	path(a, c, w) :- path(a, b, w1), path(b, c, w2), w = w1 + w2.

	// Test nested aggregation in a rule.
	test1 :- path(a, b, _), num = count({p | p is path(a,b,_), count({x | x is path(Node("n1"), Node("n2"), _)}) = 1}).

	// Calculate the number of paths between each pair of nodes.
	pathCount(a, b, num) :- path(a, b, _), num = count({p | p is path(a,b,_)}).

	// Compute the shortest path between each pair of nodes.
	shortestPath(a, b, shortest) :- path(a, b, _), shortest = minAll(0, {c | path(a,b,c)}), shortest: Integer.

	// Compute all possible path length between each pair of nodes.
	allPathLength(a, b, lists) :- path(a, b, _), lists = toList(#Ints, NIL, {c,111 | path(a,b,c)}), lists : Ints.


}

model g of WeightedGraph
{
	n1 is Node("n1").
	n2 is Node("n2").
	n3 is Node("n3").
	n4 is Node("n4").

	nodes1 is Nodes(Node("x"), Nodes(Node("y"), Nodes(Node("z"), NIL))).
	nodes2 is Nodes(Node("y"), Nodes(Node("z"), NIL)).

	e1 is Edge(n1, n2, 1).
	e2 is Edge(n2, n3, 2).
	e3 is Edge(n3, n4, 3).
	e4 is Edge(n1, n4, 1).
}

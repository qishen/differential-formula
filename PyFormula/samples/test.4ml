domain D
{

 g ::= new (any Data, any Data).

 f ::= new (Integer, Integer).
 
 Enum ::= { 1..2 }.
 
f(x, z) :- f(x, y), x = y + 1, z = x + y, z > 0.

//// f(x, z) :- f(x, x), x = y + 1, z = x + y, z > 0.

f(x, z) :- f(x, x), y : Enum, x = y + 1, z = x + y, z > 0.

f(x, z) :- f(x, x), y : Enum, x - 1 = y, z = x + y, z > 0.

f(x, z) :- f(y, y), y : Enum, x = y + 1, z = x + y, z > 0.

f(x, z) :- f(x, x), y = x, z = f(y, y), z != f(x, x).

f(x, z) :- a is f(x, x), b is f(y, y), a = b, x != y. 

f(x, y) :- a is f(x, x), b is f(y, y), a = b. 

q :- a is g(y, y), b is g(x, g(x, x)), a = b.

/// Not recursive
g(x, x) :- a is g(x, g(x, x)).

g(x, g(g(x, x), g(x, x))) :- a is g(x, c), c = g(x, x).

//// a[1][0] = a[0]

/// Because head cannot unify with body
/// g(x, x) = g(x, g(x, x))
/// =>
/// x = g(x, x)

//// Forall f, x, y. x = y => f(x) = f(y).
//// Forall f, x, y. f(x) = f(y) => x = y. [For data constructors]

}


domain X
{
   Node ::= new (Integer).
   Edge ::= new (src: any Node, dst: any Node).

   List1 ::= (Node, List1 + { NIL }).
   List2 ::= (Node, List2 + { NIL }).
   List3 ::= (Node, List3 + { NIL }).

   G ::= new ({ #List1, #List2, #List3 }).

   q :- G(y), toList(y, NIL, {x | x is Node }) != NIL.

   conforms Edge(x, y).

   conforms Edge(y, z).
}

partial model M of X
{
   requires count({ x | x is Edge(%a, z)}) > 10.

   Edge(a, b).
   Edge(b, c).
}

domain Y
{
   F ::= new (Integer).

   U ::= { blue, red }.

   q :- F(1).
}


transform T (a:: X) returns (b:: X)
{
   b.Edge(x, x) :- a.Edge(x, x).
}


domain Z includes X, Y
{
   q :- X.q; Y.q.
   q :- X.q, Y.q.
}

domain W includes a:: X, b:: X, c:: X
{
   F ::= (b.Node + c.Node).

   F(x) :- a.Edge(x, x).
}

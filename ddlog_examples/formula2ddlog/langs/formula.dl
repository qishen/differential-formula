import langs::lib::list
import langs::lib::operators

/***********************************************/
/******* FORMULA 2.0 Language Meta-model *******/
/***********************************************/

// There are some restrictions on the field name for each variant that they have to be unique
typedef Term =  AtomStr { i0: string } | AtomInt { i1: signed<64> } | AtomPosInt { i2: signed<64> } |
				AtomNegInt { i3: signed<64> } | AtomFloat { i4: float } | AtomBool { i5: bool } |
			    Variable { root: string, fragments: Vec<string> } |
				// Constant can be viewed as Composite term without arguments
				Composite { name: string, arguments: List<Ref<Term>> }

// TODO: Field name is actually optional
typedef Field = Field { field_name: string, type_spec: TypeSpec }
typedef TypeSpec =  Integer | Boolean | FloatNum | String |
					CompositeType { name: string, arguments: Vec<Field> } |
					UnionType { name: string, subtypes: Vec<TypeSpec> } |
					EnumType {name: string, items: Vec<Term>} |
					ConstantType {constant: string} 

// The head terms and conditions are the same as head and body in a rule so the set 
// comprehension can be viewed as a rule and set comprehension is applied to the set
// of derived terms
typedef Setcompre = Setcompre { rule: Ref<Rule>, sop: SetOp, default: Term }
typedef Expr =  BaseExpr { term: Term } | 
				SetcompreExpr { sc: Ref<Setcompre> } |
				UnaryExpr { expr: Ref<Expr>, uop: UnaryOp } |
				ArithExpr { left: Ref<Expr>, right: Ref<Expr>, aop: ArithOp }

// Constraints are either predicates or expressions that may contain set comprehension	
// `ExprCons` could be 
// 1) a binary constraint over two expressions. 
// 2) An assignment that holds the result of the evaluation of right hand side expression.
// 3) Type constraint in the form of `var: Type`
typedef Constraint = PredCons { negated: bool, term: Term, alias: Option<string> } | 
					 BinaryCons { left: Expr, right: Expr, bop: BinOp } |
					 AssignCons { variable: Term, expr: Expr } | 
					 TypeCons { variable: Term, var_type: TypeSpec }

// A rule is composed by a linked list of head terms and a linked list of constraints
// Rule has at least one constraint and at least one head term otherwise the rule is meaningless
// The term in the head could be ground term and only count once in the set
typedef Rule = Rule { id: string, head: NonNullList<Term>, body: NonNullList<Constraint> }
typedef Domain = Domin { typedefs: List<TypeSpec>, rules: List<Rule> }
typedef Model = Model { terms: List<Term>}
typedef Transform = Transform {}


/****************** Relations *******************/
input relation TypeSpec [TypeSpec]
input relation InputTerm [Term]
output relation Term [Term]
// A helper relation to infer the type of variables in Formula term but also for every subterm 
// in the arguments of a term. The first term is the argument and the second term is the term
// that contains the first term as (subterm, term, the type of subterm)
output relation SubtermTypeSpec [(Term, Term, TypeSpec)]
// I don't use `Flatmap()` on `Vec<T>` because Formula does not support it and eventually  
// we want to model the languages in Formula
output relation ArgListOfTerm [(usize, List<Ref<Term>>, Term)]
output relation ArgOfTerm [(usize, Term, Term)]
// Variable in the direct arguments of a composite term, not recursively.
output relation VarOfTerm [(Term, Term)] 

// It should contain both rule in the domain and rule in the set comprehension
input relation InputRule [Rule]
output relation Rule [Rule]
output relation SetcompreRule [Rule]
output relation NonSetcompreRule [Rule]

// The head of each constraint list cannot be null otherwise it's meaningless
output relation PosPredInRule [(Term, Ref<Rule>)]
// Negative predicates can be directly use in `DDRule` as `not Pred(..)` or
// translated into set comprehension in `DDRule` rather than set difference depending on
// if the variables in negative term occur in the outer scope. 
output relation NegPredInRule [(Term, Ref<Rule>)]
output relation NegPredAsSetdiff[(Term, Ref<Rule>)]
output relation NegPredAsSetcompre[(Term, Ref<Rule>)]

// Track variables as variable terms in the positive predicates of a rule 
// TODO: How about the variables in set comprehension
output relation PosVarInRule [(Term, Ref<Rule>)]
// Track variables as variable terms in the negative predicates of a rule 
output relation NegVarInRule [(Term, Ref<Rule>)]

output relation HeadListInRule [(NonNullList<Term>, Ref<Rule>)] // Intermediate results because we use List
output relation HeadInRule[(Term, Ref<Rule>)]  
// the first item of usize is the unique index or id of the constraint
output relation ConstraintListInRule [(usize, NonNullList<Constraint>, Ref<Rule>)]
output relation ConstraintInRule [(usize, Constraint, Ref<Rule>)]

// The variable term in the rule to define Setcompre 
output relation DefTermOfSetcompre [(Term, Setcompre, Ref<Rule>)]
output relation OuterVarInDepSetcompre [(Term, Setcompre, Ref<Rule>)]
output relation Setcompre [(Setcompre, Ref<Rule>)]
output relation IndependentSetcompre [(Setcompre, Ref<Rule>)]
output relation DependentSetcompre [(Setcompre, Ref<Rule>)]

/******************** Rules *********************/
// Add all composite subterm from `InputTerm` into the `Term` relation
Term[term] :- InputTerm[term].
Rule[rule] :- InputRule[rule].

// A composite term is a subterm of itself and the type can be easily derived by checking the 
// the name of the constructor. Variable term and atom term are skipped in `SubtermTypeSpec` 
// relation because no context provided for a single variable term and the type of atom term
// can be directly obtained by calling function `atom_term_type()`.
SubtermTypeSpec[(c, c, t)] :- 
	c in Term[Composite{cons_name, arg_list}], 
	t in TypeSpec[CompositeType{cons_name, _}].

SubtermTypeSpec[(arg, ancestor, arg_type_spec)] :- 
	SubtermTypeSpec[(term, ancestor, CompositeType{_, arg_types})], 
	ArgOfTerm[(index, arg, term)],
	var arg_type_spec = arg_types.nth(index).option_unwrap_or_default().type_spec.
	
ArgListOfTerm[(0, arg_list, c)] :- c in Term[Composite{_, arg_list}].
ArgListOfTerm[(index+1, deref(nxt_arg_list), c)] :- ArgListOfTerm[(index, List {_, ListNxt {nxt_arg_list}}, c)].
ArgOfTerm[(index, deref(term_ref), c)], Term[deref(term_ref)] :- ArgListOfTerm[(index, List {term_ref, _}, c)].
VarOfTerm[(variable, variable)] :- variable in Term[Variable{}].
VarOfTerm[(variable, term)] :- pair in ArgOfTerm[(_, Variable{}, term)], var variable = pair.1.

HeadListInRule[(head_head, ref_new(r))] :- r in Rule[Rule {_, head_head, _}].
HeadListInRule[(deref(nxt_head), r)] :- HeadListInRule[(NonNullList {_, NonNullNxt { nxt_head }}, r)].
HeadInRule[(term, r)] :- HeadListInRule[(NonNullList {term, _}, r)].

ConstraintListInRule[(0, constraint_head, ref_new(r))] :- r in Rule[Rule{ _, _, constraint_head }].
ConstraintListInRule[(index + 1, deref(nxt_constraint), r)] :- 
	ConstraintListInRule[(index, NonNullList {_, NonNullNxt { nxt_constraint }}, r)].
ConstraintInRule[(index, constraint, r)] :- ConstraintListInRule[(index, NonNullList {constraint, _}, r)]. 

// Add all positive and negative terms into the Term relation
Term[pos_term], PosPredInRule[(pos_term, r)] :- ConstraintInRule[(_, PredCons {false, pos_term, _}, r)].
Term[neg_term], NegPredInRule[(neg_term, r)] :- ConstraintInRule[(_, PredCons {true, neg_term, _}, r)].
PosVarInRule[(variable, r)] :- PosPredInRule[(pos_term, r)], VarOfTerm[(variable, pos_term)].
NegVarInRule[(variable, r)] :- NegPredInRule[(neg_term, r)], VarOfTerm[(variable, neg_term)].
NegPredAsSetdiff[(neg_pred, r)] :- PosVarInRule[(variable, r)], NegVarInRule[(variable, r)], 
	VarOfTerm[(variable, neg_pred)], 
	NegPredInRule[(neg_pred, r)].
NegPredAsSetcompre[(neg_pred, r)] :- NegPredInRule[(neg_pred, r)], not NegPredAsSetdiff[(neg_pred, r)].  

// Add inner rule of set comprehension back into the Rule relation
Rule[inner_rule],
SetcompreRule[inner_rule],
Setcompre[(setcompre, rule)], 
DefTermOfSetcompre[(def_term, setcompre, rule)] :-
	ConstraintInRule[(_, AssignCons{def_term, SetcompreExpr{setcompre_ref}}, rule)],
	var setcompre = deref(setcompre_ref),
	var inner_rule = deref(setcompre.rule).

// Use negation to derive all rules that are not from inside set comprehension
NonSetcompreRule[rule] :- Rule[rule], not SetcompreRule[rule].

DependentSetcompre[(setcompre, rule)], OuterVarInDepSetcompre[(shared_var, setcompre, rule)] :- 
	Setcompre[(setcompre, rule)],
	var sc_rule = setcompre.rule,
	// TODO: What about the negative variables in rules?
	PosVarInRule[(shared_var, sc_rule)], 
	PosVarInRule[(shared_var, rule)].

IndependentSetcompre[(setcompre, rule)] :- Setcompre[(setcompre, rule)], 
	not DependentSetcompre[(setcompre, rule)].

/***********************************************************/
/******* Helper Functions for Formula 2.0 Meta-model *******/
/***********************************************************/

function is_primitive_type(type_spec: TypeSpec): bool {
	match (type_spec) {
		Integer -> true,
		Boolean -> true,
		FloatNum -> true,
		String -> true,
		_ -> false
	}
}

function to_string(type_spec: TypeSpec): string {
	match (type_spec) {
		Integer -> { "Int" },
		Boolean -> { "Bool" },
		FloatNum -> { "Float" },
		String -> { "String" },
		CompositeType {cons_name, _} -> { cons_name },
		UnionType {union_name, _} -> { union_name },
		ConstantType {constant} -> { constant },
		EnumType {enum_name, _} -> { enum_name }
	}
}

function to_string(term: Term): string {
	match (term) {
		AtomStr { str } -> str,
		AtomInt { i } -> to_string(i),
		AtomPosInt { i } -> to_string(i),
		AtomNegInt { i } -> to_string(i),
		AtomFloat { f } -> to_string(f),
		AtomBool { b } -> to_string(b),
		Variable { root, fragments } -> {
			if (vec_len(fragments) == 0) {
				root
			} else {
				root ++ "." ++ fragments.join(".")
			}
		},
		Composite { name, args} -> {
			var arg_str_list = list_map(args, |x| to_string(deref(x)));
			var arg_str_vec = into_vec(arg_str_list);
			var args_str = arg_str_vec.join(", ");
			name ++ "(" ++ args_str ++ ")"
		},
	} 
}

import group
import langs::ddlog
import langs::formula
import langs::lib::list
import langs::lib::operators

/**********************************************************/
/******* Model Transformation from Formula to DDlog *******/
/**********************************************************/

/****************** Relations for Transformation ******************/
// Still in the form of `no pred(..)`
output relation DDNegPredAsSetdiff[(DDRhs, Ref<Rule>)]
// Convert `no pred(..)` to count({ p | p is Pred(..) }) == 0
// Pred(..), var g = (v1, v2, ..., vn).group_by(()), 
// var reduced_val = g.group_count(), reduced_val == 0.
// The relation contains tuples of 
// 1) The variable in the negated term
// 2) The Rhs expression that contains a positive term
// 3) The current rule
// Generate a new relation with a constant type as a switch for negated predicate as set comprehension
output relation DDNegPredAsSetcompre[(Term, DDRhs, Ref<Rule>)]

// Extract term from each term list in the head of set comprehension and derive its type
output relation TermListInSetcompreHead [(NonNullList<Term>, Setcompre, Ref<Rule>)]
output relation DDTermInSetcompreHead [(DDTerm, Setcompre, Ref<Rule>)]
output relation DDTypeSpecInSetcompreHead [(DDTypeSpec, Setcompre, Ref<Rule>)]

output relation DDAtomInRule [(DDAtom, Ref<Rule>)]
output relation DDRhsInRule [(DDRhs, Ref<Rule>)]
output relation AtomVecOfRule [(Vec<DDAtom>, Ref<Rule>)]
output relation RhsVecOfRule [(Vec<DDRhs>, Ref<Rule>)]


/************** Rules for Transformation ****************/

// Mapping of primitive type from Formula to DDlog
DDTypeSpec[Int] :- TypeSpec[Integer].
DDTypeSpec[Bool] :- TypeSpec[Boolean].
DDTypeSpec[Float] :- TypeSpec[FloatNum].
DDTypeSpec[Str] :- TypeSpec[String].

// Generate DDlog type and relation for each Formula type
// Since Formula does not distinguish between input and output relations but DDlog does, we need to 
// define two relations for the same type with a rule as `T[t] :- Tinput[t]`
DDTypeSpec[dd_type], 
DDRelation[dd_input_relation], DDRelation[dd_relation], 
DDRule[DDRule { input_rule_head, input_rule_body }] :- 
	TypeSpec[t], not is_primitive_type(t),
	var dd_type = to_dd_typespec(t),
	var rel_name = to_string(t),
	var input_rel_name = rel_name ++ "Input",
	var dd_relation = DDRelation { false, rel_name, dd_type },
	var dd_input_relation = DDRelation { true, input_rel_name, dd_type },
	// An input rule: T[p] :- TInput[p]
	var pterm = DDVar{"p"},
	var atom = ddterm_to_ddatom(None, ref_new(dd_relation), pterm),
	var input_rule_head = [atom],
	var input_atom = ddterm_to_ddatom(None, ref_new(dd_input_relation), pterm),
	var input_ddrhs = DDRhsAtom {false, input_atom},
	var input_rule_body = [input_ddrhs].

/**************** Handle Positive Predicate Term in Rule ********************/
// If the head term is a boolean variable like hascycle :- no Path(u, u).
// Need to generate a new typedef and relation named `BoolConstantHasCycle` to represent hascycle
DDTypeSpec[constant_type], 
DDRelation[constant_relation],
DDAtomInRule[(boolean_atom, rule_ref)] :- 
	HeadInRule[(Variable{root, _}, rule_ref)], 
	var rule = deref(rule_ref),
	// Ignore rule in set comprehension because its head will be rewritten in an other way
	NonSetcompreRule[rule],
	var constant_name = "BoolConstant" ++ root, 
	// typedef BoolConstantX = BoolConstantX{}
	var constructor = DDTypeCons { constant_name, EMPTY },
	var constant_type = DDUnionTypeSpec { constant_name, from_singleton_to_nonnull_list(constructor) }, 
	// output relation BoolConstantX [BoolConstantX{}]
	var constant_relation = DDRelation { false, constant_name, constant_type },
	// BoolConstantX[BoolConstantX{}] as the new head predicate to replace the variable term in the head
	// BoolConstantX[BoolConstantX{}] :- constraints.
	var boolean_atom = ddterm_to_ddatom(None, ref_new(constant_relation), DDCons{constant_name, EMPTY}). 

// If the head term is a composite term with variables then nothing needs to change
DDAtomInRule[(atom, rule_ref)] :- pair in HeadInRule[(Composite{relname, _}, rule_ref)], 
	var rule = deref(rule_ref),
	// Ignore rule in set comprehension because its head will be rewritten in an other way
	NonSetcompreRule[rule],
	rel in DDRelation[DDRelation {_, relname, _}], 
	var head_term = pair.0,
	var dd_head_term = to_dd_term(head_term),
	var atom = ddterm_to_ddatom(None, ref_new(rel), dd_head_term). 

DDRhsInRule[(positive_dd_rhs_atom, rule)] :- pair in PosPredInRule[(Composite {relname, _}, rule)], 
	// Find the relation by the name of the composite term
	rel in DDRelation[DDRelation {_, relname, _}], 
	ConstraintInRule[(_, PredCons {false, pos_term, optional_alias}, rule)],
	pos_term == pair.0,
	var dd_term = to_dd_term(pos_term),
	var positive_dd_rhs_atom = ddterm_to_ddrhs(optional_alias, ref_new(rel), dd_term, false).

/**************** Handle Negative Predicate Term in Rule ********************/
// Translate a DDTerm `no Pred(..)` into a DDRhs such as `not x in Relation[Pred(..)]` as set difference
DDRhsInRule[(negated_dd_rhs_atom, rule)] :- pair in NegPredAsSetdiff[(Composite {relname, _}, rule)], 
	rel in DDRelation[DDRelation {_, relname, _}], 
	var neg_term = pair.0,
	var dd_term = to_dd_term(neg_term), 
	var negated_dd_rhs_atom = ddterm_to_ddrhs(None, ref_new(rel), dd_term, true). 

// Translate a negated DDTerm `no Pred(..)` into set comprehension in the format of Formula as 
// `no_such_pred :- x = count({ p | Pred(..) }), x == 0`.
//
// 1. Generate a new rule in the format of DDlog:
// BoolRelation[BoolConstant{}]:- p in Pred(..), var g = (p).group_by(()), var num = g.group_count(), num == 0.
//
// 2. The negation in original rule is replaced by a new predicate composed by the new `BoolRelation` and 
// `BoolConstant` type as `Head :- C1, C2, ..., BoolRelation[BoolConstant{}], CN.`
DDTypeSpec[constant_type], 
DDRelation[constant_relation],
DDRhsInRule[(dd_rhs_bool_constant_atom, rule)], 
DDRule[DDRule { head, body }]:-
	pair in NegPredAsSetcompre[(Composite {relname, _}, rule)],  
	rel in DDRelation[DDRelation {_, relname, _}], 
	// Negated predicate should not have alias
	ConstraintInRule[(constraint_id, PredCons {true, neg_term, _}, rule)],
	neg_term == pair.0,
	var rule_id = rule.id,
	var dd_neg_term = to_dd_term(neg_term), 
	// Synthesize a new name for the new constant type and relation e.g. BoolConstantR1N2
	var constant_name = "BoolConstant" ++ "R" ++ rule_id ++ "N" ++ constraint_id, 
	var constructor = DDTypeCons { constant_name, EMPTY },
	// For example, typedef BoolConstantR1N2 = BoolConstantR1N2 {}
	// output relation BoolConstantR1N2 [BoolConstantR1N2{}]
	var constant_type = DDUnionTypeSpec { constant_name, from_singleton_to_nonnull_list(constructor) }, 
	var constant_relation = DDRelation { false, constant_name, constant_type },
	// Generate `BoolConstantRelation[p]` as one of the Rhs to replace negated predicate in the origin rule
	var dd_rhs_bool_constant_atom = ddterm_to_ddrhs(None, ref_new(constant_relation), DDVar{"p"}, false), 
	// The head should be BoolConstant[BoolConstant{}] 
	var head = [DDAtom { None, ref_new(constant_relation), DDTermExpr{ref_new(DDCons{constant_name, EMPTY})} }],
	// From a positive term `p in Pred[Pred(..)]` to a RHS expression in DDlog.
	var dd_atom_rhs = ddterm_to_ddrhs(Some{"p"}, ref_new(rel), dd_neg_term, false),
	// var g = (p).group_by(()).
	var p_ref = ref_new(DDVar { "p" }),
	var p_expr_ref = ref_new(DDTermExpr { p_ref }),
	var p_vec = [p_expr_ref],
	var group_assignment = DDGroup { "g", DDTupleExpr{p_vec}, DDTupleExpr{vec_empty()} }, 
	// var num = g.group_count().
	var g_ref = ref_new(DDVar { "g" }),
	var g_expr_ref = ref_new(DDTermExpr { g_ref }),
	// num = ...
	var num_ref = ref_new(DDVar { "num" }),
	// var num = ...
	var num_assign_ref = ref_new(DDVarDecl { "num" }),
	var num_expr = DDTermExpr { num_ref },
	var num_assign_expr = DDTermExpr { num_assign_ref },
	var aggregation_expr = DDDotFunctionCallExpr { g_expr_ref, "group_count", vec_empty() },
	var num_assignment = DDRhsAssignment { num_assign_expr, aggregation_expr },
	// num == 0. 
	var zero_ref = ref_new(DDInt { 0 }),
	var zero_expr_ref = ref_new(DDTermExpr{zero_ref}),
	var count_is_zero = DDRhsCondition { DDBinExpr {ref_new(num_expr), zero_expr_ref, Eq} },
	var body = [dd_atom_rhs, group_assignment, num_assignment, count_is_zero].

/************** Handle Independent Set Comprehension **************/
TermListInSetcompreHead[(sc_rule.head, setcompre, rule)] :- 
	IndependentSetcompre[(setcompre, rule)], var sc_rule = deref(setcompre.rule).

TermListInSetcompreHead[(nxt_nonnull_list, setcompre, rule)] :- 
	TermListInSetcompreHead[(NonNullList { _, NonNullNxt { nxt_nonnull_list_ref } }, setcompre, rule)],
	var nxt_nonnull_list = deref(nxt_nonnull_list_ref).

// This relation contains all terms in the head of set comprehension and the terms could be 
// variable term or even ground term
DDTermInSetcompreHead[(ddterm, setcompre, rule)] :- 
	TermListInSetcompreHead[(term_nonnull_list, setcompre, rule)],
	var term = term_nonnull_list.node, 
	var ddterm = to_dd_term(term).

// The type of atom term could be found by checking the type of the value of the atom,
DDTypeSpecInSetcompreHead[(ddtypespec, setcompre, rule)] :- 
	DDTermInSetcompreHead[(dd_atom_term, setcompre, rule)], 
	var type_opt = atom_term_type(dd_atom_term),
	type_opt.is_some(), 
	var ddtypespec = type_opt.unwrap_or_default().

// The type of composite term could be found by the name of constructor,
DDTypeSpecInSetcompreHead[(ddtypespec, setcompre, rule)] :- 
	DDTermInSetcompreHead[(DDCons {cons_name, _}, setcompre, rule)], 
	ddtypespec in DDTypeSpec[DDUnionTypeSpec{cons_name, _}].

// The type of variable term has to be inferred within the context of the set comprehension
DDTypeSpecInSetcompreHead[(dd_variable_type_spec, setcompre, rule)] :- 
	tuple in DDTermInSetcompreHead[(DDVar{}, setcompre, rule)], 
	PosPredInRule[(setcompre_pred, setcompre_rule)],
	// Since we know the type of every variable in a composite term in relation `SubtermTypeSpec`, 
	// it's easy to derive the type of variable that occur in both head and body of set comprehension
	SubtermTypeSpec[(variable_term, setcompre_pred, variable_type_spec)],
	var dd_variable_head_term = tuple.0,
	setcompre_rule == setcompre.rule,
	dd_variable_head_term == to_dd_term(variable_term),
	var dd_variable_type_spec = to_dd_typespec(variable_type_spec).	

// 1. Create a new union type to represent all types in the head of set comprehension 
// `typedef SCHeadUnionR0SC1 = T1 { i0: T1} | T2 { i1: T2 } | ... Tn { in: Tn }`
// `SCHeadUnionR0SC1` means the second set comprehension in the first rule 
// A new relation is created to hold all records of the union type 
// every term in the head of set comprehension is wrapped in a new constructor `Ti {term}` 
// before adding to the new output relation
// `output relation SCHeadUnionR0SC1 [SCHeadUnionR0SC1]`
DDTypeSpec[setcompre_head_union_type], 
DDRelation[setcompre_head_ddrelation] :- 
	IndependentSetcompre[(setcompre, rule)],
	DDTypeSpecInSetcompreHead[(ddtype, setcompre, rule)],
	ConstraintInRule[(setcompre_id, AssignCons{def_term, SetcompreExpr{setcompre_ref}}, rule)],
	setcompre == deref(setcompre_ref),
	var ddtype_group = (ddtype).group_by((setcompre_id, setcompre, rule)),
	var ddtype_vec = ddtype_group.map(|t| t),
	(var sc_id, var sc, var r) = ddtype_group.group_key(),
	var rule_id = r.id,
	// The name of new union type should include the rule id and the setcompre id
	var union_type_name = "SCHeadUnion" ++ "R" ++ rule_id ++ "SC" ++ sc_id, 
	// Generate `typedef SCHeadUnion = T1 { i0: T1} | T2 { i1: T2 } | ... Tn { in: Tn}`
	// given a list of types `ddtype_vec = [T1, T2, ..., Tn]`
	var setcompre_head_union_type = union_of_ddtypes(union_type_name, ddtype_vec),
	var setcompre_head_ddrelation = DDRelation { false, union_type_name, setcompre_head_union_type }.

// 2. Generate a new rule in the format of DDlog to derive terms in the head:
// SCHeadUnion[T1{h1}], SCHeadUnion[T1{h2}], SCHeadUnion[Tn{hn}] :- SCPred(v1, v2,..., vn), SCPredn(..). 
// in which `hn` may contain the variables in `SCPred(v1,...,vn)` which is the predicate constraint in
// the set comprehension
DDAtomInRule[(dd_atom_for_sc_rule, sc_rule)] :- 
	IndependentSetcompre[(setcompre, rule)], 
	// TODO: What if the head term is variable or atom? headache..
	tuple in DDTermInSetcompreHead[(DDCons {cons_name, _}, setcompre, rule)], 
	ConstraintInRule[(sc_id, AssignCons{def_term, SetcompreExpr{setcompre_ref}}, rule)],
	var dd_head_term = tuple.0,
	setcompre == deref(setcompre_ref),
	var rule_id = rule.id,
	var sc_rule = setcompre.rule,
	var union_type_name = "SCHeadUnion" ++ "R" ++ rule_id ++ "SC" ++ sc_id,
	// Wrap the term into SCHeadUnion_T{term} because of the union type of all types in the head
	var wrapped_dd_head_term = DDCons {
		union_type_name ++ "_" ++ cons_name, 
		from_singleton_to_list(DDTermExpr{ref_new(dd_head_term)}) 
	},
	var dd_sc_head_term_expr = DDTermExpr { ref_new(wrapped_dd_head_term) }, 
	// Find the auto-generated new relation by name
	dd_sc_head_union_relation in DDRelation[DDRelation {_,union_type_name,_}],
	// SCHeadUnion[tn] where `tn` is the term from the head of set comprehension
	var dd_atom_for_sc_rule = DDAtom { None, ref_new(dd_sc_head_union_relation), dd_sc_head_term_expr }.

// 3. New relation and type to hold the result of set comprehension
// typedef SCResultR0SC1 = SCResultR0SC1Int {i: usize} | SCResultR0SC1Float {f: float}
DDTypeSpec[setcompre_result_type], 
DDRelation[setcompre_result_ddrelation] :- 
	IndependentSetcompre[(setcompre, rule)],
	ConstraintInRule[(setcompre_id, AssignCons{def_term, SetcompreExpr{setcompre_ref}}, rule)],
	setcompre == deref(setcompre_ref),
	var rule_id = rule.id,
	// The name of new union type should include the rule id and the setcompre id
	var sc_result_name = "SCResult" ++ "R" ++ rule_id ++ "SC" ++ setcompre_id, 
	// TODO: Think about the type of aggregation results other than int and float.
	// FIXME: the field name cannot be float or usize because they are reserved
	var setcompre_result_type = union_of_ddtypes(sc_result_name, [Int, Float]),
	var setcompre_result_ddrelation = DDRelation { false, sc_result_name, setcompre_result_type }.

// 4. The set comprehension `def_term = SetOp({..})` in the original rule is replaced with a new rule
// and a predicate associated with the definition term in the original rule. 
// SCResultR0SC1[SCResultR0SC1_Int{ result }] :- SCHeadUnion[t], var g = (t).group_by(()), 
// var result = g.group_count().
// Original rule only has predicates in it:
// Head :- SCResultR0SC1[SCResult_usize{def_term}], C1, C2, ..., Cn.
// One rule could have multiple `SCResultXXX[SCResultXXX{}]` atoms without conflicts
DDRule[DDRule { [sc_result_head_atom], [dd_head_union_atom_rhs, group_assignment, result_assignment] }],
DDRhsInRule[(dd_head_union_atom_rhs_with_def, rule)] :-
	IndependentSetcompre[(setcompre, rule)], 
	ConstraintInRule[(sc_id, AssignCons{def_term, SetcompreExpr{setcompre_ref}}, rule)],
	setcompre == deref(setcompre_ref),
	var dd_def_term = to_dd_term(def_term),
	var rule_id = rule.id,
	var union_type_name = "SCHeadUnion" ++ "R" ++ rule_id ++ "SC" ++ sc_id,
	var sc_result_name = "SCResult" ++ "R" ++ rule_id ++ "SC" ++ sc_id,
	dd_sc_head_union_relation in DDRelation[DDRelation {_,union_type_name,_}],
	dd_sc_result_relation in DDRelation[DDRelation {_,sc_result_name,_}],
	// Add a new Rhs SCHeadUnion[t] to the new rule
	var dd_head_union_atom_rhs = ddterm_to_ddrhs(
		None, 
		ref_new(dd_sc_head_union_relation), 
		DDVar{"t"}, 
		false),
	// Add a new Rhs `SCResult[SCResult_usize{def_var_term}]` to the original rule
	var dd_head_union_atom_rhs_with_def = ddterm_to_ddrhs(
		None, 
		ref_new(dd_sc_result_relation), 
		DDCons{ 
			// TODO: the type of result depends on the setcompre.sop
			// Should we just force all values of aggregation to float type
			sc_result_name ++ "_usize", 
			from_singleton_to_list(DDTermExpr{ref_new(DDVar{ to_string(dd_def_term) })}) 
		}, 
		false),
	// var g = (t).group_by(()).
	var t_ref = ref_new(DDVar { "t" }),
	var t_expr_ref = ref_new(DDTermExpr { t_ref }),
	var t_vec = [t_expr_ref],
	var group_assignment = DDGroup { "g", DDTupleExpr{t_vec}, DDTupleExpr{vec_empty()} }, 
	// var result = g.group_count().
	var result_ref = ref_new(DDVarDecl { "result" }),
	var result_expr = DDTermExpr { result_ref },
	var g_ref = ref_new(DDVar { "g" }),
	var g_expr_ref = ref_new(DDTermExpr { g_ref }),
	// TODO: Replace `group_count` based on the exact setcompre.sop
	var aggregation_expr = DDDotFunctionCallExpr { g_expr_ref, "group_count", vec_empty() },
	var result_assignment = DDRhsAssignment { result_expr, aggregation_expr },
	// SCResult[SCResult_usize{result}] :- three constraints.
	var sc_result_head_term = DDCons { 
		// TODO: the type of result depends on the setcompre.sop
		sc_result_name ++ "_usize", 
		from_singleton_to_list(DDTermExpr{ref_new(DDVar{ "result" })}) 
	}, 
	var sc_result_head_atom = DDAtom { 
		None, 
		ref_new(dd_sc_result_relation), 
		DDTermExpr { ref_new(sc_result_head_term) } 
	}.


/************** Handle Dependent Set Comprehension *************/
// The shared variables between outer scope and inner scope of set comprehension cannot occur
// in the nested inner set comprehension inside the current set comprehension.
//    o1
// ------------ rule
//         |s1|  i1 = o2
//         ------------------ setcompre(1) inside rule
//						 |s2|   i2
//                  	 ------------ setcompre(2) inside previous setcompre(1)
//
// o1 and o2 represent the variables in the outer scope
// i1 and i2 represent the variables in the inner scope of set comprehension
// s1 and s2 represent the shared variable between inner and outer scope


// 1. Create a new union type to represent all types in the head of set comprehension
// typedef SCHeadUnion = T1 { i0: T1} | T2 { i1: T2 } | ... Tn { in: Tn}
// 
// 2. Generate a new rule in the format of DDlog:
// SCHeadUnion[T1{h1}], SCHeadUnion[T1{h2}], SCHeadUnion[Tn{hn}] :- SCPred(v1, v2,..., vn), SCPredn(..). 
// in which `hn` may contain the variables in `Pred(v1,...,vn)`
// 
// 3. The set comprehension `def_term = SetOp({..})`in the original rule is replaced by three atoms 
// Head :- SCHeadUnion[t], var g = (t).group_by(()), var def_term = g.group_count(), C1, C2,..., Cn.
// in which `Cn` is the remaining non-aggregation constraints in the rule.

// DDTypeSpec[setcompre_head_union_type], DDRelation[setcompre_head_ddrelation] :- 
// 	OuterVarInDepSetcompre[(shared_var, setcompre, rule)],
// 	DependentSetcompre[(setcompre, rule)],
// 	DDTypeSpecInSetcompreHead[(ddtype, setcompre, rule)],
// 	var ddtype_group = (ddtype).group_by((setcompre, rule)),
// 	var ddtype_vec = ddtype_group.map(|t| t),
// 	// setcompre and rule are both consumed in the aggregation
// 	(var sc, var r) = ddtype_group.group_key(),
// 	var rule_id = r.id,
// 	// TODO: The name of new union type should include
// 	// TODO: Add the index of setcompre rule id and setcompre id
// 	var union_type_name = "SCHeadUnion" ++ rule_id, 
// 	var setcompre_head_union_type = union_of_ddtypes(union_type_name, ddtype_vec),
// 	var setcompre_head_ddrelation = DDRelation { false, union_type_name, setcompre_head_union_type }.


/***************** Create New DDRule in DDlog ********************/
AtomVecOfRule[(atom_vec, rule_ref)] :- Rule[rule], var rule_ref = ref_new(rule), DDAtomInRule[(ddatom, rule_ref)], 
	var atom_group = (ddatom).group_by((rule_ref)),
	var atom_vec = atom_group.map(|atom| atom).

RhsVecOfRule[(rhs_vec, rule_ref)] :- Rule[rule], var rule_ref = ref_new(rule), DDRhsInRule[(ddrhs, rule_ref)], 
	var rhs_group = (ddrhs).group_by((rule_ref)),
	var rhs_vec = rhs_group.map(|rhs| rhs).

// Combine head and body into a DDRule.
DDRule[ddrule] :- AtomVecOfRule[(atom_vec, rule)], RhsVecOfRule[(rhs_vec, rule)],
	var ddrule = DDRule { atom_vec, rhs_vec }.

/********** Helper Functions for Transformation **********/
function to_dd_term(term: Term): DDTerm {
	var dd_term = match (term) {
		AtomStr { str } -> DDStr { str },
		AtomInt { int } -> DDInt { int },
		AtomPosInt { pint } -> DDInt { pint },
		AtomNegInt { nint } -> DDInt { nint },
		AtomFloat { float_num } -> DDFloat { float_num },
		AtomBool { boolean } -> DDBool { boolean },
		// TODO: What about the fragments
		Variable { root, fragments } -> { DDVar { root } },
		Composite { name, term_ref_arguments_head } -> {
			var term_arguments_head = list_map(term_ref_arguments_head, |t_ref| {
				deref(t_ref)
			});
			var dd_expr_arguments_head = list_map(term_arguments_head, |t| { 
				var dd_t = to_dd_term(t);
				DDTermExpr { ref_new(dd_t) } 
			});
			DDCons { name, dd_expr_arguments_head }
		},
	};
	dd_term
}

// Recursively translate a Formula type spec into DDlog type spec 
function to_dd_typespec(type_spec: TypeSpec): DDTypeSpec {
	var dd_type_spec = match (type_spec) {
		CompositeType {name, fields} -> {
			var ddfields = vec_empty();
			for (field in fields) {
				var ddtypespec = to_dd_typespec(field.type_spec);
				// Field name has to start with lowercase letter
				vec_push(ddfields, DDField { to_lowercase(field.field_name), ref_new(ddtypespec) });
			};
			var dd_cons = DDTypeCons { name, from_vec(ddfields) };
			DDUnionTypeSpec { name, from_singleton_to_nonnull_list(dd_cons) }
		},
		UnionType {union_name, subtypes} -> {
			// From Formula union type to tagged union in DDlog
			// TODO: How to merge union types rather than create a new tagged union?
			// A ::= B + C.  D ::= E + F.  G ::= A + D.
			// X1 ::= Y1 + NULL, X2 ::= Y2 + NULL 
			var dd_cons_types = vec_empty();
			for (subtype in subtypes) {
				var dd_subtype_spec = to_dd_typespec(subtype);
				var union_tag = union_name ++ "_" ++ type_alias(dd_subtype_spec);
				// Field name has to start with lowercase letter
				var field_name = to_lowercase(type_alias(dd_subtype_spec)) ++ "_field";
				var single_dd_field = DDField { field_name, ref_new(dd_subtype_spec) };
				var field_list = [single_dd_field];
				var dd_cons_type = DDTypeCons { union_tag, from_vec(field_list) };
				vec_push(dd_cons_types, dd_cons_type);
			};
			DDUnionTypeSpec { union_name, from_nonnull_vec(dd_cons_types).unwrap_or_default() }
		},
		ConstantType {constant} -> { 
			// A constructor with no arguments or fields as `typedef Constant = Constant {}`
			// The vector can not be empty in `DDTypeCons` so we create a new type named `Empty`
			var empty_list = vec_empty();
			var dd_constant_cons_type = DDTypeCons {
				constant, 
				from_vec(empty_list)
			};
			DDUnionTypeSpec { constant, from_singleton_to_nonnull_list(dd_constant_cons_type) }	
		},
		// TODO: How to handle ConstantType and EnumType?
		EnumType {enums, _} -> { Str },
		Integer -> { Int },
		Boolean -> { Bool },
		FloatNum -> { Float },
		String -> { Str }
	};
	dd_type_spec
}
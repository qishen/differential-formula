import list
import operators
import ddlog

/***********************************************/
/******* FORMULA 2.0 Language Meta-model *******/
/***********************************************/

// There are some restrictions on the field name for each variant that they have to be unique
typedef Term =  AtomStr { i0: string } | AtomInt { i1: signed<64> } | AtomPosInt { i2: signed<64> } |
				AtomNegInt { i3: signed<64> } | AtomFloat { i4: float } | AtomBool { i5: bool } |
			    Variable { root: string, fragments: Vec<string> } |
				// Constant can be viewed as Composite term without arguments
				Composite { name: string, arguments: List<Ref<Term>> }

// Store all the terms from rules or more places like model and transformation depending on your need
input relation InputTerm [Term]
output relation Term [Term]
output relation ArgListOfTerm [(List<Ref<Term>>, Term)]
output relation ArgOfTerm [(Term, Term)]
output relation VarOfTerm [(Term, Term)]
// Add all composite subterm from `InputTerm` into the `Term` relation
Term[term] :- InputTerm[term].
// Recursively find all argument of a composite term
ArgListOfTerm[(arg_list, c)] :- c in Term[Composite{_, arg_list}].
ArgListOfTerm[(deref(nxt_arg_list), c)] :- ArgListOfTerm[(List {_, ListNxt {nxt_arg_list}}, c)].
ArgOfTerm[(deref(term_ref), c)], Term[deref(term_ref)] :- ArgListOfTerm[(List {term_ref, _}, c)].

// Variable term is in variable term itself
VarOfTerm[(v, v)] :- v in Term[Variable{}].
VarOfTerm[(variable, term)] :- pair in ArgOfTerm[(Variable{}, term)], var variable = pair.0.

// TODO: Field name is actually optional
typedef Field = Field { field_name: string, type_spec: TypeSpec }
typedef TypeSpec =  Integer | Boolean | FloatNum | String |
					CompositeType { name: string, arguments: Vec<Field> } |
					UnionType { name: string, subtypes: Vec<TypeSpec> } |
					EnumType {name: string, items: Vec<Term>} |
					ConstantType {constant: string} 

// A relation named TypeSpec to hold all instance of TypeSpec
input relation TypeSpec [TypeSpec]

// The head terms and conditions are the same as head and body in a rule so the set 
// comprehension can be viewed as a rule and set comprehension is applied to the set
// of derived terms
typedef Setcompre = Setcompre { rule: Ref<Rule>, sop: SetOp, default: Term }
typedef Expr =  BaseExpr { term: Term } | 
				SetcompreExpr { sc: Ref<Setcompre> } |
				UnaryExpr { expr: Ref<Expr>, uop: UnaryOp } |
				ArithExpr { left: Ref<Expr>, right: Ref<Expr>, aop: ArithOp }

// Constraints are either predicates or expressions that may contain set comprehension	
// `ExprCons` could be 
// 1) a binary constraint over two expressions. 
// 2) An assignment that holds the result of the evaluation of right hand side expression.
// 3) Type constraint in the form of `var: Type`
typedef Constraint = PredCons { negated: bool, term: Term } | 
					 BinaryCons { left: Expr, right: Expr, bop: BinOp } |
					 AssignCons { variable: Term, expr: Expr } | 
					 TypeCons { variable: Term, var_type: TypeSpec }

// The head of each constraint list cannot be null otherwise it's meaningless
output relation ConstraintList [NonNullList<Constraint>]
output relation Constraint [Constraint] 
// Recursively add all constraints into the relations starting from the head
ConstraintList[deref(nxt)], Constraint[cons] :- ConstraintList[NonNullList {cons, NonNullNxt { nxt }}].

typedef PositivePred = PositivePred { rule: Rule, term: Term }
output relation PositivePred [PositivePred]

typedef NegativePred = NegativePred { rule: Rule, term: Term }
output relation NegativePred [NegativePred]

// A rule is composed by a linked list of head terms and a linked list of constraints
// Rule has at least one constraint and at least one head term otherwise the rule is meaningless
// The term in the head could be ground term and only count once in the set
typedef Rule = Rule { head: NonNullList<Term>, body: NonNullList<Constraint> }
// TODO: Don't forget to set comprehension into the Rule input relation too 
input relation Rule [Rule]

// Find all constraints in a rule.
output relation ConstraintListInRule [(NonNullList<Constraint>, Ref<Rule>)]
output relation ConstraintInRule [(Constraint, Ref<Rule>)]
ConstraintListInRule[(constraint_head, ref_new(r))] :- r in Rule[Rule{ _, constraint_head }].
ConstraintListInRule[(deref(nxt_constraint), r)] :- ConstraintListInRule[
	(NonNullList {_, NonNullNxt { nxt_constraint }}, r)
].
ConstraintInRule[(constraint, r)] :- ConstraintListInRule[(NonNullList {constraint, _}, r)]. 

// Track positive predicates as terms in a rule
output relation PosPredInRule [(Term, Ref<Rule>)]
PosPredInRule[(pos_term, r)] :- ConstraintInRule[(PredCons {false, pos_term}, r)].

// Track negative predicates as terms in a rule
output relation NegPredInRule [(Term, Ref<Rule>)]
NegPredInRule[(neg_term, r)] :- ConstraintInRule[(PredCons {true, neg_term}, r)].

// Track variables as variable terms in the positive predicates of a rule 
// TODO: How about the variables in set comprehension
output relation PosVarInRule [(Term, Ref<Rule>)]
PosVarInRule[(variable, r)] :- PosPredInRule[(pos_term, r)], VarOfTerm[(variable, pos_term)].

// Track variables as variable terms in the negative predicates of a rule 
output relation NegVarInRule [(Term, Ref<Rule>)]
NegVarInRule[(variable, r)] :- NegPredInRule[(neg_term, r)], VarOfTerm[(variable, neg_term)].

// Track all Setcompre definition in a rule
output relation SetcompreInRule [(Term, Setcompre, Ref<Rule>)]
SetcompreInRule[(def_term, deref(setcompre_ref), r)] :- ConstraintInRule[
	(AssignCons{def_term, SetcompreExpr{setcompre_ref}}, r)
].

/******************* Translate Set Comprehension ************************/
// The shared variables between outer scope and inner scope of set comprehension cannot occur
// in the nested inner set comprehension inside the current set comprehension.
//    o1
// ------------ rule
//         |s1|  i1 = o2
//         ------------------ setcompre(1) inside rule
//						 |s2|   i2
//                  	 ------------ setcompre(2) inside previous setcompre(1)
//
// o1 and o2 represent the variables in the outer scope
// i1 and i2 represent the variables in the inner scope of set comprehension
// s1 and s2 represent the shared variable between inner and outer scope

// Track all independent Setcompre in a rule, which are not dependent Setcompre
// The first term in the tuple is the definition term
output relation IndependentSetcompre [(Term, Setcompre, Ref<Rule>)]
IndependentSetcompre[(def_term, setcompre, rule)] :- SetcompreInRule[(def_term, setcompre, rule)], 
	not DependentSetcompre[(def_term, _, setcompre, rule)].

// The second term in the tuple is the shared variable with outer scope
output relation DependentSetcompre [(Term, Term, Setcompre, Ref<Rule>)]
DependentSetcompre[(def_term, shared_var, setcompre, rule)] :- 
	sc_tuple in SetcompreInRule[(def_term, Setcompre {sc_rule, _, _}, rule)],
	var setcompre = sc_tuple.1,
	// TODO: What about the negative variables in rules?
	PosVarInRule[(shared_var, sc_rule)], PosVarInRule[(shared_var, rule)].

output relation DDTermListOfIndepSetcompreHead [(NonNullList<Term>, Setcompre, Ref<Rule>)]
DDTermListOfIndepSetcompreHead[(sc_rule.head, setcompre, rule)] :- sc_tuple in IndependentSetcompre[(
	def_term, Setcompre{}, rule)], 
	var setcompre = sc_tuple.1, 
	var sc_rule = deref(setcompre.rule).
DDTermListOfIndepSetcompreHead[(deref(nxt_nonnull_list_ref), setcompre, rule)] :- DDTermListOfIndepSetcompreHead[(
	NonNullList { _, NonNullNxt { nxt_nonnull_list_ref } }, 
	setcompre, rule)
].

// Extract term from each term list in the head of set comprehension 
output relation DDTypeSpecOfIndepSetcompreHead [(DDTypeSpec, Setcompre, Ref<Rule>)]
DDTypeSpecOfIndepSetcompreHead[(ddtypespec, s, r)] :- DDTermListOfIndepSetcompreHead[(list, s, r)],
	var term = list.node, var ddterm = to_dd_term(term),
	DDTermOfDDTypeSpec[(ddterm, ddtypespec)].

// DDTypeSpec[] :- DDTypeSpecOfIndepSetcompreHead[(ddtype, setcompre, rule)],
// 	var types = (ddtype).group_by((setcompre, rule));


// output relation DDTypeSpecInSetcompreHead[(DDTypeSpec, Setcompre, Ref<Rule>)]
// DDTypeSpecInSetcompreHead[(sc_tuple.1, sc_tuple.2)] :- 

// Generate a new relation and new type for the head in the set comprehension



typedef Domain = Domin { typedefs: List<TypeSpec>, rules: List<Rule> }
typedef Model = Model { terms: List<Term>}
typedef Transform = Transform {}


function to_string(type_spec: TypeSpec): string {
	var type_spec_str = match (type_spec) {
		Integer -> { "Int" },
		Boolean -> { "Bool" },
		FloatNum -> { "Float" },
		String -> { "String" },
		CompositeType {cons_name, _} -> { cons_name },
		UnionType {union_name, _} -> { union_name },
		ConstantType {constant} -> { constant },
		EnumType {enum_name, _} -> { enum_name }
	};
	type_spec_str
}

function to_dd_term(term: Term): DDTerm {
	var dd_term = match (term) {
		AtomStr { str } -> DDStr { str },
		AtomInt { int } -> DDInt { int },
		AtomPosInt { pint } -> DDInt { pint },
		AtomNegInt { nint } -> DDInt { nint },
		AtomFloat { float_num } -> DDFloat { float_num },
		AtomBool { boolean } -> DDBool { boolean },
		Variable { root, fragments } -> {
			DDVar { root }
		},
		Composite { name, term_ref_arguments_head } -> {
			var term_arguments_head = list_map(term_ref_arguments_head, |t_ref| {
				deref(t_ref)
			});
			var dd_expr_arguments_head = list_map(term_arguments_head, |t| { 
				var dd_t = to_dd_term(t);
				DDTermExpr { ref_new(dd_t) } 
			});
			DDCons { name, dd_expr_arguments_head }
		},
	};
	dd_term
}

// Recursively translate a Formula type spec into DDlog type spec 
function to_dd_typespec(type_spec: TypeSpec): DDTypeSpec {
	var dd_type_spec = match (type_spec) {
		CompositeType {name, fields} -> {
			var ddfields = vec_empty();
			for (field in fields) {
				var ddtypespec = to_dd_typespec(field.type_spec);
				vec_push(ddfields, DDField { field.field_name, ref_new(ddtypespec) });
			};
			var dd_cons = DDTypeCons { name, from_vec(ddfields) };
			DDUnionTypeSpec { from_singleton_to_nonnull_list(dd_cons) }
		},
		UnionType {union_name, subtypes} -> {
			// From Formula union type to tagged union in DDlog
			// TODO: How to merge union types rather than create a new tagged union?
			// A ::= B + C.  // D ::= E + F.  // G ::= A + D.
			var dd_cons_types = vec_empty();
			for (subtype in subtypes) {
				var dd_subtype_spec = to_dd_typespec(subtype);
				var union_tag = union_name ++ to_string(subtype);
				var single_dd_field = DDField { union_tag, ref_new(dd_subtype_spec) };
				var field_list = [single_dd_field];
				var dd_cons_type = DDTypeCons { union_tag, from_vec(field_list) };
				vec_push(dd_cons_types, dd_cons_type);
			};
			DDUnionTypeSpec { from_nonnull_vec(dd_cons_types) }
		},
		ConstantType {constant} -> { 
			// A constructor with no arguments or fields as `typedef Constant = Constant {}`
			// The vector can not be empty in `DDTypeCons` so we create a new type named `Empty`
			var empty_list = vec_empty();
			var dd_constant_cons_type = DDTypeCons {
				constant, 
				from_vec(empty_list)
			};
			DDUnionTypeSpec { from_singleton_to_nonnull_list(dd_constant_cons_type) }	
		},
		// TODO: How to handle ConstantType and EnumType?
		EnumType {enums, _} -> { Str },
		Integer -> { Int },
		Boolean -> { Bool },
		FloatNum -> { Float },
		String -> { Str }
	};
	dd_type_spec
}
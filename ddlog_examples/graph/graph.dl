// Generate ddlog runtime with std lib specified.
// Bash command: ddlog -i graph.dl -L ~/differential-datalog/lib/

// There is a bug in ddlog that type name cannot be single letter.
// input relation NN(id: u32)
// input relation EE(src: u32, dst: u32)

// typedef StrId = string
// typedef NumId = u32 
// typedef NID = StrId | NumId turns out to be two constants.
// Another bug here? Two constructors cannot have the same field name?
typedef NID = StrId {nid: string} | NumId {nnid: u32} | Constant1 | Constant2

// You cannot derived new facts for input relation
// The workaround to emulate Formula is to create two relations for each type with a mapping rule.
// input relation NodeInput(id: u32)
// output relation Node(id: u32)

// input relation Node(id: u32) is actually syntax sugar. 
// typedef Node = Node {id: u32}
// Declare the relation by specifying it record type.
// input relation Node [Node] or input relation DummyNode [Node]
// DummyNode[node] :- Node[node], is_dummy(node).
input relation Node(id: usize)
input relation Edge(src: Node, dst: Node)

// It will cause naming conflict and they will be treated as constants. 
// typedef Item = Node | Edge
// Must wrap them in constructors if you want enum of two defined types.
// typedef Item = ItemNode{node: Node} | ItemEdge{edge: Edge}

output relation TwoEdge(src: Edge, dst: Edge)
output relation Path(src: Node, dst: Node)
output relation Line(one: Node, two: Node, three: Node, four: Node)
output relation NoCycle(node: Node)

// output relation HasCycle(inner: bool)
typedef HasCycleConstant = HasCycleConstant {}
output relation HasCycle(inner: HasCycleConstant)

// Recurisve type defintion is supported too!
// Linked list of nodes with recursive type and NodeListNxt could be either `NodeList`
// or NULL to be terminated.
typedef NodeListNxt = Nxt {list: Ref<NodeList>} | NULL 
output relation NodeList(item: Node, next: NodeListNxt)

// Create a node list where a node points to itself as a self-linked list.
// we cannot use `nxt in Nxt()` because Nxt is not a relation but just a constructor.
// Node[node] or node in Node() are the same expression to access all items in the relation `Node` 
// in which the type of each item is also `Node` but different from relation `Node`.
NodeList(node, nxt) :- Node[node], var single_node = NodeList{node, NULL}, var nxt = Nxt{ref_new(single_node)}. 

// The rule order does not matter here.
// Path(a, c) :- Path(a, b), Path(b, c).
// Nested predicate is supported too
Path(Node{a}, Node{c}) :- Path(Node{a}, Node{b}), Path(Node{b}, Node{c}).

// Add some additional constraints to the matches from predicate constraints  
// Path(Node{e}, Node{c}) :- Path(Node{a}, Node{b}), Path(Node{b}, Node{c}), var e = a + 100, c > 1.
// Constraint over attributes inside terms.
// Path(a, c) :- Path(a, b), Path(b, c), b.id != c.id.
Path(Node{a}, Node{b}) :- Edge(Node{a}, Node{b}). 

// Let's make a production rule.
// Production rule without additional constraints fails to compile?
// TwoEdge(Edge{Node{a}, b}, Edge{c, d}) :- Edge(Node{a}, b), Edge(c, d).
// TwoEdge(Edge{a, b}, Edge{c, d}) :- Edge(a, b), Edge(c, d), b == c.

// Rule with negation to prove the absence of cycle.
// For every Path(u, v) if Path(u, u) does not exist then NoCycle(u) is derived.
// NoCycle(u) :- Path(u, v), not Path(u, u).
// What we want is to check if there is no Path(u, u) in the database.
// What ddlog does is to do a set difference between two sets.
// set1 of Node[u] is a set of all existing nodes and set2 is a set of nodes that appear in Path(u, u).
// Two ways to write it:
// NoCycle(u) :- Node[u], not Path(u, u).
// Bind variable `u` to a row of `Node` relation while u = Node(..) does not accept variable inside.
NoCycle(u) :- u in Node(), not Path(u, u).

// Emulate Formula rule in which the head is a boolean variable
// Actually we cannot have `HasCycle(true)` and `HasCycle(false)` at the same time but ddlog may allow it.
// `HasCycle(true)` can be used as boolean variable in the body of a rule.
// The existence of `HasCycle(true)` means true and the absence of it means false.
// `HasCycle(false)` is skipped and maybe we can use a Constant type for the field inside `HasCycle()`
// as `HasCycle(inner: SingleConstant)` where `SingleConstant` has only one value to choose from.
// HasCycle(true) :- u in Node(), not NoCycle(u).
// Yes we can do it! `HasCycle()` is a relation that has at most one item `HasCycle(HasCycleConstant)` inside it 
HasCycle(HasCycleConstant) :- u in Node(), not NoCycle(u).

// More than one term in the head. DDLog will create something like Multi(a, b, c) to 
// represent both head terms
// Path(a, b), Path(b, a) :- Edge(a, b).

// Let's do some Aggregation in FORMULA.
output relation Outdegree(node: Node, count: usize)
// Calculate the outdegree for each node in the graph.
// NodeCount(num) :- num = count({ a | Node(a)}).
Outdegree(Node{src}, sum) :- Edge(Node{src}, Node{dst}), var sum = dst.group_by(src).group_count().  


// TODO: Nested Aggregation sounds challenging?
// For each outgoing edge (x, y) from a cycle-free node, we count the number of outgoing edges
// starting from y and the count must be larger than a number so (x, y) can be added into the set
// of { x, y | condition } and the set will be further aggregated. 
// Ok, now we have a set of (x, y) pairs and we want to compute the sum of them but note that the 
// real set return from set comprehension is just a set of integers so we need to remove all duplicates
// before summing up.
// NodeIdSum(idsum) :- idsum = sum({ x, y | NoCycle(Node(x)), 
//					Edge(Node(x), Node(y)), 
//					count({ z | Edge(Node(y), Node(z)) }) > 4 })
// Let's break it down into two rules.
output relation NodeIdSum(sum: usize)
output relation HeadIntSet(num: usize)
HeadIntSet(xx), HeadIntSet(yy) :- NoCycle(Node{x}), Edge(Node{x}, Node{y}), Edge(Node{y}, Node{z}), 
	var g = z.group_by((x, y)),
	// All variables like x, y, z are all consumed in the scope and cannot be accessed
	// unless we explicitly use `group_key()` to store and access the key.
	(var xx, var yy) = g.group_key(), 
	// For each key (x, y), the number of z in the group has to be larger than 2.
	g.group_count() > 2.
// Group by nothing so it returns a group that has all integers in the set.
NodeIdSum(sum) :- HeadIntSet(num), var sum = num.group_by(()).group_sum().

// Let's make a little change to connect set comprehension with each cycle-free node from outer scope.
// The difference from previous nested aggregation is that we are doing set comprehension for each
// separate x and also we can move `NoCycle(Node(x))` to the outer scope without changing the semantic
// NodeIdSum(x, idsum) :- Node(x), idsum = sum({ x, y | NoCycle(Node(x)), 
//					Edge(Node(x), Node(y)), 
//					count({ z | Edge(Node(y), Node(z)) }) > 4 })
// Let's break it down into two rules.
output relation NodeIdSumByX(node: Node, sum: usize)
output relation HeadXY(x: usize, y: usize)
HeadXY(x, y) :- Node(x), NoCycle(Node{x}), Edge(Node{x}, Node{y}), Edge(Node{y}, Node{z}), 
	var g = z.group_by((x, y)),
	// All variables like x, y, z are all consumed in the scope and cannot be accessed
	// unless we explicitly use `group_key()` to store and access the key.
	(var xx, var yy) = g.group_key(), 
	// For each key (x, y), the number of z in the group has to be larger than 2.
	g.group_count() > 2.
NodeIdSumByX(Node{xx}, sum) :- HeadXY(x, y), var g = y.group_by(x), var xx = g.group_key(), 
			var sum_of_ys = g.group_sum(), var sum = sum_of_ys + xx.

// Mutually recursive rules
// program::ProgNode::SCC{rels: vec![
//     program::RecursiveRelation{rel: Path, distinct: true}, 
//     program::RecursiveRelation{rel: Line, distinct: true}
// ]},
// Both `Path` and `Line` are put into an inner scope of loop that keeps deriving
// new facts until fix point reached.
// Path(a, b) :- Edge(a, b).
// Line(a, b, a, b) :- Path(a, b).
// Path(b, b) :- Line(a, b, c, d).

// Rules that look dependent but actually not because of the semantics of the predicates
// Path(Node{1}, x) and Path(Node{2}, y) represent different subsets of terms.
// DDLog treats two rules separately
// Line(x, x, x, x) :- Path(2, x).
// Path(3, x) :- Path(2, x).
// Path(2, y) :- Edge(y, 2).

// Join multiple predicates in the rule body and can we do some worst case optimal joins?
// TODO: Check how ddlog schedules the joins. 
// 1. Join Edge(a, b), Edge(b, c) into (c, a, b) and each one is DDValue
// Arrange Edge(a, b), Edge(b, c) by c as (c, (c, a, b)) 
// 2. Join Edge(a, b), Edge(b, c), Edge(c, d) into (d, c, a, b)
// Arrange it by d as (d, (d, c, a, b))
// Path(a, e) :- Edge(a, b), Edge(b, c), Edge(c, d), Edge(d, e), b == c + 2.
// Path(a, c) :- Path(a, b), Path(b, c).
// NoCycle(u) :- Edge(_, u), not Path(u, u).
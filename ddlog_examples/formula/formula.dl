/***********************************************/
/******* Extra Library for General Usage *******/
/***********************************************/

// Define two types of generic linked lists similar to list definition in Formula 

// `NonNullList` in Formula representation:
// LinkedList ::= new (node: N, nxt: LinkedList + NULL)
// The `NonNullList` must have at least one item in the list and can't be null
typedef NonNullList<'N> = NonNullList { node: 'N, nxt: NonNullNxt<'N> }
typedef NonNullNxt<'N> = NonNullNxt { nxt: Ref<NonNullList<'N>> } | NULL

function nonnull_list_map(list: NonNullList<'N>, f: function('N): 'M): NonNullList<'M> {
	var new_node = f(list.node);
	var mapped_nonnull_nxt = match (list.nxt) {
		NonNullNxt {nxt_nonnull_list_ref} -> {
			var nxt_nonnull_list = deref(nxt_nonnull_list_ref);
			var mapped_nonnull_list = nonnull_list_map(nxt_nonnull_list, f);
			NonNullNxt { ref_new(mapped_nonnull_list) }
		},
		NULL -> NULL
	};
	NonNullList { 
		new_node, 
		mapped_nonnull_nxt
	}
}

function from_singleton_to_nonnull_list(item: 'N): NonNullList<'N> {
	NonNullList { item, NULL }
}

function from_nonnull_vec(vector: Vec<'N>): NonNullList<'N> {
	var first = unwrap_or_default(vec_nth(vector, 0));
	NonNullList { first, NULL }
}

// `List` in Formula representation:
// NonNullLinkedList ::= new (node: N, nxt: LinkedList)
// LinkedList ::= NonNullLinkedList + NULL 
typedef List<'N> = List { node: 'N, nxt: ListNxt<'N> } | EMPTY
typedef ListNxt<'N> = ListNxt { nxt: Ref<List<'N>> }

function from_singleton_to_list(item: 'N): List<'N> {
	List { item, ListNxt {ref_new(EMPTY)} }
}

function from_vec(vector: mut Vec<'N>): List<'N> {
	if (vec_len(vector) == 0) {
		EMPTY
	} else {
		var last = vector.pop().unwrap_or_default();
		var list_without_last = from_vec(vector);
		list_append(list_without_last, last)
	}
}

// Since `Ref<List<'N>>` is immutable we have to make a deep copy and append the new item
function list_append(list: mut List<'N>, item: 'N): List<'N> {
	match (list) {
		List { node, ListNxt { nxt_list_ref } } -> {
			var nxt_list = deref(nxt_list_ref);
			var nxt_list_with_item = list_append(nxt_list, item);
			List { node, ListNxt { ref_new(nxt_list_with_item) } }
		},
		EMPTY -> {
			List { item, ListNxt { ref_new(EMPTY) } }
		}
	}
}

function list_reverse(list: mut List<'N>): List<'N> {
	match (list) {
		List { node, ListNxt {nxt_list_ref} } -> {
			// TODO: Deref literally on every iteration is bad.
			var nxt_list = deref(nxt_list_ref);
			var reversed_nxt_list = list_reverse(nxt_list);
			list_append(reversed_nxt_list, node)
		},
		EMPTY -> EMPTY
	}
}

function map_list(list: List<'N>, f: function('N): 'M): List<'M> {
    match (list) {
		List { node, ListNxt {nxt_list_ref} } -> {
			var nxt_list = deref(nxt_list_ref);
			var mapped_nxt_list = map_list(nxt_list, f);
			List { f(node), ListNxt {ref_new(mapped_nxt_list)} }
		},
		EMPTY -> EMPTY
    }
}


/***********************************************/
/******* FORMULA 2.0 Language Meta-model *******/
/***********************************************/

// There are some restrictions on the field name for each variant that they have to be unique
typedef Term =  AtomStr { i0: string } | AtomInt { i1: signed<64> } | AtomPosInt { i2: signed<64> } |
				AtomNegInt { i3: signed<64> } | AtomFloat { i4: float } | AtomBool { i5: bool } |
			    Variable { root: string, fragments: Vec<string> } |
				// Constant can be viewed as Composite term without arguments
				Composite { name: string, arguments: List<Ref<Term>> }

// Store all the terms from rules or more places like model and transformation depending on your need
input relation InputTerm [Term]
output relation Term [Term]
output relation ArgListOfTerm [(List<Ref<Term>>, Term)]
output relation ArgOfTerm [(Term, Term)]
output relation VarOfTerm [(Term, Term)]
// Add all composite subterm from `InputTerm` into the `Term` relation
Term[term] :- InputTerm[term].
// Recursively find all argument of a composite term
ArgListOfTerm[(arg_list, c)] :- c in Term[Composite{_, arg_list}].
ArgListOfTerm[(deref(nxt_arg_list), c)] :- ArgListOfTerm[(List {_, ListNxt {nxt_arg_list}}, c)].
ArgOfTerm[(deref(term_ref), c)], Term[deref(term_ref)] :- ArgListOfTerm[(List {term_ref, _}, c)].

// Variable term is in variable term itself
VarOfTerm[(v, v)] :- v in Term[Variable{}].
VarOfTerm[(pair.0, term)] :- pair in ArgOfTerm[(Variable{}, term)].

// TODO: Field name is actually optional
typedef Field = Field { field_name: string, type_spec: TypeSpec }
typedef TypeSpec =  Integer | Boolean | FloatNum | String |
					CompositeType { name: string, arguments: Vec<Field> } |
					UnionType { name: string, subtypes: Vec<TypeSpec> } |
					EnumType {name: string, items: Vec<Term>} |
					ConstantType {constant: string} 

// A relation named TypeSpec to hold all instance of TypeSpec
input relation TypeSpec [TypeSpec]

// Definition of common operators in both Formula and DDlog expression
typedef SetOp = Sum | Count | Max | Min
typedef ArithOp = Plus | Minus | Mul | Div
typedef BinOp = Eq | Neq | LE | GE | Leq | Geq 
typedef UnaryOp = BooleanNeg | BitwiseNeg | ArithNeg

// The head terms and conditions are the same as head and body in a rule so the set 
// comprehension can be viewed as a rule and set comprehension is applied to the set
// of derived terms
typedef Setcompre = Setcompre { rule: Rule, sop: SetOp, default: Term }
typedef Expr =  BaseExpr { term: Term } | 
				SetcompreExpr { sc: Ref<Setcompre> } |
				UnaryExpr { expr: Ref<Expr>, uop: UnaryOp } |
				ArithExpr { left: Ref<Expr>, right: Ref<Expr>, aop: ArithOp }

// Constraints are either predicates or expressions that may contain set comprehension	
// `ExprCons` could be 
// 1) a binary constraint over two expressions. 
// 2) An assignment that holds the result of the evaluation of right hand side expression.
// 3) Type constraint in the form of `var: Type`
typedef Constraint = PredCons { negated: bool, term: Term } | 
					 BinaryCons { left: Expr, right: Expr, bop: BinOp } |
					 AssignCons { variable: Term, expr: Expr } | 
					 TypeCons { variable: Term, var_type: TypeSpec }
// The head of each constraint list cannot be null otherwise it's meaningless
output relation ConstraintList [NonNullList<Constraint>]
output relation Constraint [Constraint] 
// Recursively add all constraints into the relations starting from the head
ConstraintList[deref(nxt)], Constraint[cons] :- ConstraintList[NonNullList {cons, NonNullNxt { nxt }}].

typedef PositivePred = PositivePred { rule: Rule, term: Term }
output relation PositivePred [PositivePred]

typedef NegativePred = NegativePred { rule: Rule, term: Term }
output relation NegativePred [NegativePred]

// A rule is composed by a linked list of head terms and a linked list of constraints
// Rule has at least one constraint otherwise the rule is meaningless
typedef Rule = Rule { head: List<Term>, body: NonNullList<Constraint> }
input relation Rule [Rule]

// Find all constraints in a rule
// ConstraintListInRule ::= new (a: ConstraintList, b: Rule). 
output relation ConstraintListInRule [(NonNullList<Constraint>, Ref<Rule>)]
// ConstraintInRule ::= new (a: Constraint, b: Rule). 
output relation ConstraintInRule [(Constraint, Ref<Rule>)]
ConstraintListInRule[(constraint_head, ref_new(r))] :- r in Rule[Rule{ _, constraint_head }].
ConstraintListInRule[(deref(nxt_constraint), r)] :- ConstraintListInRule[
	(NonNullList {_, NonNullNxt { nxt_constraint }}, r)
].
ConstraintInRule[(constraint, r)] :- ConstraintListInRule[(NonNullList {constraint, _}, r)]. 

// Track positive predicates as terms in a rule
output relation PosPredInRule [(Term, Ref<Rule>)]
PosPredInRule[(pos_term, r)] :- ConstraintInRule[(PredCons {false, pos_term}, r)].

// Track negative predicates as terms in a rule
output relation NegPredInRule [(Term, Ref<Rule>)]
NegPredInRule[(neg_term, r)] :- ConstraintInRule[(PredCons {true, neg_term}, r)].

// Track variables as variable terms in the positive predicates of a rule 
// TODO: How about the variables in set comprehension
output relation PosVarInRule [(Term, Ref<Rule>)]
PosVarInRule[(variable, r)] :- PosPredInRule[(pos_term, r)], VarOfTerm[(variable, pos_term)].

// Track variables as variable terms in the negative predicates of a rule 
output relation NegVarInRule [(Term, Ref<Rule>)]
NegVarInRule[(variable, r)] :- NegPredInRule[(neg_term, r)], VarOfTerm[(variable, neg_term)].

// Track all Setcompre definition in a rule
output relation SetcompreInRule [(Term, Setcompre, Ref<Rule>)]
SetcompreInRule[(def_term, deref(setcompre_ref), r)] :- ConstraintInRule[
	(AssignCons{def_term, SetcompreExpr{setcompre_ref}}, r)
].

// TODO: Imagine we have 100 layers of nested set comprehension
// The shared variables between outer scope and inner scope of set comprehension cannot occur
// in the nested inner set comprehension inside the current set comprehension.


typedef Domain = Domin { typedefs: List<TypeSpec>, rules: List<Rule> }
typedef Model = Model { terms: List<Term>}
typedef Transform = Transform {}


/*****************************************/
/******* DDLog Language Meta-model *******/
/*****************************************/
typedef DDField = DDField { field_name: string, type_spec: Ref<DDTypeSpec> }
typedef DDTypeCons = DDTypeCons { cons_name: string, fields: List<DDField> }
typedef DDTypeSpec = BigInt | Bool | Str | Bitvector | Int | Double | Float | // All supported primitive types
					 // Represent either at least one type or an union of multiple types
					 DDUnionTypeSpec { types: NonNullList<DDTypeCons> } |
					 Empty 

// A relation to hold all defined types in DDlog
output relation DDTypeSpec [DDTypeSpec]

// There are more term types defined in the DDlog language reference but we only need a few
// https://github.com/vmware/differential-datalog/blob/master/doc/language_reference/language_reference.md
typedef DDTerm = DDBigInt { i0: bigint } | DDBool { i1: bool } | DDStr { i2: string } |
				 // It could be different value other than 32
				 DDBitvector { i3: bit<32> } | DDInt { i4: signed<64> } | 
				 DDDouble { i5: double} | DDFloat { i6: float } | 
				 // A variable term in ddlog represented by a string
				 DDVar { name: string } | 
				 // var xxx = .., add keyword in the front to denote it is only for declaration
				 DDVarDecl { name: string} | 
				 // It has type name and a list of DDlog expressions
				 DDCons { cons_name: string, arguments: List<DDExpr> } 
				 // TODO: Add function term for aggregation

// DDRelation represents a collection of records of certain type
typedef DDRelation = DDRelation { is_input: bool, name: string, type_spec: DDTypeSpec } 
// A relation to hold all defined DDRelation
output relation DDRelation [DDRelation]

// There are more expression in DDlog referene and we only pick a few we need
typedef DDExpr =  DDTermExpr { term: Ref<DDTerm> } | 
				  // Access struct field by identifier	
				  DDTermFieldExpr { expr: Ref<DDExpr>, field: string } |
				  // Unary operator over expression
				  DDUnaryExpr { expr: Ref<DDExpr>, uop: UnaryOp } |
				  // Arithmetic operator over two expressions
				  DDArithExpr { left: Ref<DDExpr>, right: Ref<DDExpr>, aop: ArithOp } |
				  // Binary operator over two expressions
				  DDBinExpr { left: Ref<DDExpr>, right: Ref<DDExpr>, bop: BinOp }

// The complete form of DDlog predicate is `u in RelName[Term]` to represent predicate constraint
typedef DDAtom = DDAtom { var_name: Option<string>, rel: Ref<DDRelation>, expr: DDExpr }
typedef DDRhs = DDRhsAtom { negated: bool, atom: DDAtom } |
			  	DDRhsCondition { expr: DDExpr } |
			  	DDRhsAssignment { to: DDExpr, from: DDExpr } |
				// TODO: `SetOp` could be replaced or extended by function term
				// if the default set comprehension operators are not enough
				DDGroup { var_name: string, group: DDExpr, by: DDExpr, sop: SetOp }

typedef DDRule = DDRule { head: Vec<DDAtom>, body: Vec<DDRhs> }
output relation DDRule [DDRule]


/************************************/
/******* Model Transformation *******/
/************************************/
DDTypeSpec[Int] :- TypeSpec[Integer].
DDTypeSpec[Bool] :- TypeSpec[Boolean].
DDTypeSpec[Float] :- TypeSpec[FloatNum].
DDTypeSpec[Str] :- TypeSpec[String].

// TODO: Since Formula does not distinguish between input and output relations but DDlog does, we need to 
// define two relations for the same type with a rule as `T[t] :- t in T_input[..]`
DDRelation[dd_relation], DDTypeSpec[single_union_type] :- ct in TypeSpec[CompositeType {cons_name, fields}], 
				var single_union_type = to_dd_typespec(ct),
				var dd_relation = DDRelation {true, cons_name, single_union_type}.

DDRelation[dd_relation], DDTypeSpec[dd_union_type] :- ut in TypeSpec[UnionType {union_name, subtypes}], 
				var dd_union_type = to_dd_typespec(ut),
				var dd_relation = DDRelation {true, union_name, dd_union_type}.

DDRelation[dd_relation], DDTypeSpec[dd_constant_type] :- ct in TypeSpec[ConstantType {constant}], 
				var dd_constant_type = to_dd_typespec(ct),
				var dd_relation = DDRelation {true, constant, dd_constant_type}.

// Those negative predicates can be directly use in `DDRule`
output relation NegPredAsSetdiff[(Term, Ref<Rule>)]
NegPredAsSetdiff[(neg_pred, r)] :- PosVarInRule[(variable, r)], NegVarInRule[(variable, r)], 
								   NegPredInRule[(neg_pred, r)]. 

// Those negative predicates need to be translated into set comprehension in `DDRule`
output relation NegPredAsSetcompre[(Term, Ref<Rule>)]
NegPredAsSetcompre[(neg_pred, r)] :- NegPredInRule[(neg_pred, r)], not NegPredAsSetdiff[(neg_pred, r)].  

function ddterm_to_dd_rhs(
	var_name: Option<string>, 
	rel: Ref<DDRelation>, 
	dd_term: DDTerm, 
	negated: bool
): DDRhs {
	var dd_term_expr = DDTermExpr { ref_new(dd_term) };
	var dd_atom = DDAtom { var_name, rel, dd_term_expr };
	DDRhsAtom { negated, dd_atom }
}

// Still in the form of `no pred(..)`
output relation DDNegPredAsSetdiff[(DDRhs, Ref<Rule>)]
DDNegPredAsSetdiff[(negated_dd_rhs_atom, r)] :- pair in NegPredAsSetdiff[(Composite {relname, _}, r)], 
	rel in DDRelation[DDRelation {_, relname, _}], 
	var dd_term = to_dd_term(pair.0), 
	var negated_dd_rhs_atom = ddterm_to_dd_rhs(None, ref_new(rel), dd_term, false). 

// Convert `no pred(..)` to count({ p | p is Pred(..) }) == 0
// Pred(..), var g = (v1, v2, ..., vn).group_by(()), 
// var reduced_val = g.group_count(), reduced_val == 0.
// The relation contains tuples of 
// 1) The variable in the negated term
// 2) The Rhs expression that contains a positive term
// 3) The current rule
// Generate a new relation with a constant type as a switch for negated predicate as set comprehension
output relation DDNegPredAsSetcompre[(Term, DDRhs, Ref<Rule>)]

DDNegPredAsSetcompre[(variable, dd_rhs_atom, r)], 
DDTypeSpec[constant_type], 
DDRelation[constant_relation] :- 
	pair in NegPredAsSetcompre[(Composite {relname, _}, r)],  
	rel in DDRelation[DDRelation {_, relname, _}], 
	VarOfTerm[(variable, pair.0)],
	// Directly convert from `Term` to `DDTerm` and then to RHS expression
	var dd_term = to_dd_term(pair.0), 
	var dd_rhs_atom = ddterm_to_dd_rhs(None, ref_new(rel), dd_term, true),
	// Synthesize a new name for the new constant type and relation
	var constant_name = "hello", // TODO: Change name that includes rule id and position of neg term.
	var constructor = DDTypeCons { constant_name, EMPTY },
	var constant_type = DDUnionTypeSpec { from_singleton_to_nonnull_list(constructor) }, 
	var constant_relation = DDRelation { false, constant_name, constant_type }. 




function to_string(type_spec: TypeSpec): string {
	var type_spec_str = match (type_spec) {
		Integer -> { "Int" },
		Boolean -> { "Bool" },
		FloatNum -> { "Float" },
		String -> { "String" },
		CompositeType {cons_name, _} -> { cons_name },
		UnionType {union_name, _} -> { union_name },
		ConstantType {constant} -> { constant },
		EnumType {enum_name, _} -> { enum_name }
	};
	type_spec_str
}

function to_dd_term(term: Term): DDTerm {
	var dd_term = match (term) {
		AtomStr { str } -> DDStr { str },
		AtomInt { int } -> DDInt { int },
		AtomPosInt { pint } -> DDInt { pint },
		AtomNegInt { nint } -> DDInt { nint },
		AtomFloat { float_num } -> DDFloat { float_num },
		AtomBool { boolean } -> DDBool { boolean },
		Variable { root, fragments } -> {
			DDVar { root }
		},
		Composite { name, term_ref_arguments_head } -> {
			var term_arguments_head = map_list(term_ref_arguments_head, |t_ref| {
				deref(t_ref)
			});
			var dd_expr_arguments_head = map_list(term_arguments_head, |t| { 
				var dd_t = to_dd_term(t);
				DDTermExpr { ref_new(dd_t) } 
			});
			DDCons { name, dd_expr_arguments_head }
		},
	};
	dd_term
}

// Recursively translate a Formula type spec into DDlog type spec 
function to_dd_typespec(type_spec: TypeSpec): DDTypeSpec {
	var dd_type_spec = match (type_spec) {
		CompositeType {name, fields} -> {
			var ddfields = vec_empty();
			for (field in fields) {
				var ddtypespec = to_dd_typespec(field.type_spec);
				vec_push(ddfields, DDField { field.field_name, ref_new(ddtypespec) });
			};
			var dd_cons = DDTypeCons { name, from_vec(ddfields) };
			DDUnionTypeSpec { from_singleton_to_nonnull_list(dd_cons) }
		},
		UnionType {union_name, subtypes} -> {
			// From Formula union type to tagged union in DDlog
			// TODO: How to merge union types rather than create a new tagged union?
			// A ::= B + C.  // D ::= E + F.  // G ::= A + D.
			var dd_cons_types = vec_empty();
			for (subtype in subtypes) {
				var dd_subtype_spec = to_dd_typespec(subtype);
				var union_tag = union_name ++ to_string(subtype);
				var single_dd_field = DDField { union_tag, ref_new(dd_subtype_spec) };
				var field_list = [single_dd_field];
				var dd_cons_type = DDTypeCons { union_tag, from_vec(field_list) };
				vec_push(dd_cons_types, dd_cons_type);
			};
			DDUnionTypeSpec { from_nonnull_vec(dd_cons_types) }
		},
		ConstantType {constant} -> { 
			// A constructor with no arguments or fields as `typedef Constant = Constant {}`
			// The vector can not be empty in `DDTypeCons` so we create a new type named `Empty`
			var empty_list = vec_empty();
			var dd_constant_cons_type = DDTypeCons {
				constant, 
				from_vec(empty_list)
			};
			DDUnionTypeSpec { from_singleton_to_nonnull_list(dd_constant_cons_type) }	
		},
		// TODO: How to handle ConstantType and EnumType?
		EnumType {enums, _} -> { Str },
		Integer -> { Int },
		Boolean -> { Bool },
		FloatNum -> { Float },
		String -> { Str }
	};
	dd_type_spec
}